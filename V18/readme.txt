解决传递中文问题

当我们使用GET方式提交表单数据时，数据会被包含在URL的抽象路径中。而抽象路径部分会包含在请求的
请求行里。HTTP协议要求一个请求的请求行和消息头部分是纯文本，并且符合的字符集必须是ISO8859
这是一个欧洲字符集，不支持中文。因此中文无法被直接包含抽象路径中传递给服务端。

解决办法:
1:浏览器会先将中文数据用支持中文的字符集将其转换为2进制。(通常使用的就是页面上指定的字符集)
  <meta charset="UTF-8">
  例如:
  范传奇 --UTF-8--> 100010010110101...
  UTF-8编码中，每个中文占3个字节，因此"范传奇"会转换出9个字节。
  9个字节对应的2进制一共:8x9=72位2进制
  2进制:0和1  ISO8859-1编码中支持英文，数字和符号。我们完全可以用数字'0'和'1'表示2进制
  用72个由'0'和'1'组成的字符来表示"范传奇"对应的2进制。
  因此，在抽象路径中传递中文时可采取这种办法:
  /myweb/login?username=100001010010100....&password=123&....
                        |--------72-------|
2:新的问题:用'1'和'0'表示2进制的组合太长了。数据越多传输越慢。
  解决长度问题:使用16进制来减少长度。

2进制         10进制        16进制
0000            0           0
0001            1           1
0010            2           2
0011            3           3
0100            4           4
0101            5           5
0110            6           6
0111            7           7
1000            8           8
1001            9           9
1010            10          A
1011            11          B
1100            12          C
1101            13          D
1110            14          E
1111            15          F

将72位2进制可以缩短为18位的16进制。并且16进制出现的内容也在英文，数字，符号范围内
传递数据时:
/myweb/login?username=E88C83.....&password=123&....
                      |---18----|

新问题:
如何和实际的英文和数字区分开呢?
服务端在读取到用户名时读取到的内容:username=E88C83..
E88C83服务端是理解为16进制呢?还是这个人就叫E88C83
为了区分传递的是16进制内容还是本身的英文数字，URL规定如果表示的是16进制则每2位16进制前必须
添加一个"%"。
username=%E8%8C%83..  这里的内容就是16进制
username=E88C83..     这里的内容就是普通的英文数字

传递16进制数据时:
/myweb/login?username=%E8%8C%83.....&password=123&....

服务端获取时仅需要反向操作一遍即可还原为中文了
使用API:URLDecoder.decode()方法进行。

实现:
修改HttpServletRequest的getParameter方法，在获取参数时对参数值转码后再返回即可。






